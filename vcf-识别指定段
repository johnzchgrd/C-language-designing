#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAXLINELENGTH 200  //最大行长度 建议>=200 
char* strsearch( char *s, char *t ){
   //一般方法查找子串 
   while(*s){
   	
   	char*p=s;
   	char*m=t;
     while(*p){
       if(*p!=*m)
       break;
       p++;
       m++;
	 }
    
    if(*m=='\0')
      return s;//匹配到字符串 
   s++;
  }
  return NULL;//未匹配到字符串 
}
void get_a_row(FILE*fp, char buf[]){
	//读入回车符地读取一行
    int i=0;
    while(!feof(fp)){
		if((buf[i++]=fgetc(fp))=='\n')
		  break;
	}
    buf[i]='\0';
   //测试用printf("%s",buf);
}
FILE*to_row(FILE*fp, char *t){
	//转到字符串 t 所在行的下一行 
	char buf[MAXLINELENGTH];
	FILE*tmp=fp;
	int flag=0;
	while(!feof(fp)){
		get_a_row(fp,buf);
		if(strsearch(buf,t)!=NULL&&strsearch(t,buf)!=NULL) //两个字符串完全相等 
		   {
		   flag=1;
		   break;
		   }
	} 
	if(flag)
	  return fp;
	else{
		printf("\ncannot go to the line after \"%s\"\n",t);
		return tmp;
	}
		
}
void deletepara(FILE*fp,FILE*fp2,char*startflag,char*endflag){
	//(demo)删除指定段:从startflag开始，到（包括）endflag为止，endflag必须为完整的结束行 
	char buf[MAXLINELENGTH];
	//char startflag[MAXLINELENGTH],endflag[MAXLINELENGTH];
	/*printf("Enter STARTFLAG:\n");
	scanf("%s",startflag);
	printf("Enter ENDROW:(must be an entire row)\n");
	scanf("%s",endflag);
	*/
	while(!feof(fp)){
		get_a_row(fp,buf);
		if(strsearch(buf,startflag)!=NULL)
		   fp=to_row(fp,endflag);
		else
		   fputs(buf,fp2);				
	}
	if(feof(fp))
	  printf("Deletion finished!\n");
}
main(){
	FILE*fp,*fp2;
	long position=0;//保存文件指针位置 
	char buf[MAXLINELENGTH];
	static char filename[20];
	int count=0;
	//定义单向链表，用于保存联系人信息 
	struct contact{
		char name[20];//姓名 
		char tel[12],tel1[12],tel2[12];//电话 
		struct contact *next;//指向下一个联系人节 
	} *p,*tmp;
	//获取文件名
	 printf("filename:\n");
	 scanf("%s",filename);
	//打开文件
	if((fp=fopen(filename,"r"))==NULL){
		printf("cannot open \"%s\"!",filename);
		exit(1);
	}
	if((fp2=fopen("output.vcf","w"))==NULL){
		printf("cannot create \"output.vcf\"!");
		exit(2);
	}
	//核心部分
	/*
	//删除PHOTO段测试 
	char s[]="PHOTO;",t[]="\n";
	deletepara(fp,fp2,s,t);
	*/
	/*
	//识别单个联系人测试
	position=ftell(fp); 
	
	get_a_row(fp,buf);
	if(strsearch(buf,"BEGIN:")==buf)
	   while(1){
	   	printf("%s",buf);
	   	get_a_row(fp,buf);
	   	if(strsearch(buf,"END:")==buf){
	   		printf("%s",buf);
	   		break;
		   }
	   }
	
    if(fseek(fp,position,SEEK_SET)){
    	printf("cannot return to previous paragraph!\n");
    	exit(5);
	}
	*/
	
	//读取单个联系人信息 
	position=ftell(fp); 
	if((p=(struct contact*)malloc(sizeof(struct contact)))==NULL){
		printf("cannot allocate memory!");
		exit(6);
	}
	get_a_row(fp,buf);
	//核心判断语句 
	if(strsearch(buf,"BEGIN:")==buf)
	   while(1){
	   	get_a_row(fp,buf);
	   	if(strsearch(buf,"FN:")==buf){
	   		sscanf(buf,"FN:%s",p->name);
		   }
		if(strsearch(buf,"TEL;")==buf){
	   		switch(count){
	   			case 0:
				   sscanf(buf,"%*[^:]:%s",p->tel);
	   			   count++;
	   			   break;
	   			case 1:
	   				sscanf(buf,"%*[^:]:%s",p->tel1);
	   				count++;
	   				break;
	   			case 2:
	   				sscanf(buf,"%*[^:]:%s",p->tel2);
	   				count++;
	   				break;
			   }
		   }
	   	if(strsearch(buf,"END:")==buf)
	   	   break; 
	   }
	   //test
	   printf("%-10s%-15s%-15s%-15s\n","姓名","电话1","电话2","电话3"); 
	   printf("%-10s%-15s%-15s%-15s",p->name,p->tel,p->tel1,p->tel2);

	free(p);
    if(fseek(fp,position,SEEK_SET)){
    	printf("cannot return to previous paragraph!\n");
    	exit(5);
	}
    
    
	//关闭文件
	if(fclose(fp)){
		printf("cannot close \"%s\"!",filename);
		exit(3);
	}
	if(fclose(fp2)){
		printf("cannot close \"output.vcf\"!");
		exit(4);
	}
	return 0;
}

