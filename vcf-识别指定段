#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define MAXLINELENGTH 200  //最大行长度 建议>=200 
/*
 *author: https://github.com/johnzchgrd
 *date: 2019.2
 *support-vcf-version: 3.0
 *functions: 
 *1、删除指定段 * 
 *2、识别联系人信息并显示 * 
 *3、联系人去空、乱码（格式控制） 
 *4、合并重复联系人
 *5、功能3、4输出为.vcf文件 
 *6、功能2实现一页一页显示 
 *7、支持version 2.1和version 3.0转换（quoted-printable编码） 
 *8、支持修改单个联系人信息并保存到文件 
 *9、功能1能做到智能识别有多少种段并以选项形式呈现 
 *10、整合与拆分联系人
 *
 * 
 */ 
struct contact{
		int id;
		char name[31];//姓名 
	    char tel[12],a,tel1[12],b,tel2[12],c,tel3[12];//电话1，2，3，4 ，插入a,b,c原理未知，不过可以防止（应该是）sscanf函数的副作用 
		struct contact *next;//指向下一个联系人节 
	}; 
char* strsearch( char *s, char *t ){
   //一般方法查找子串 
   while(*s){
   	
   	char*p=s;
   	char*m=t;
     while(*p){
       if(*p!=*m)
       break;
       p++;
       m++;
	 }
    
    if(*m=='\0')
      return s;//匹配到字符串 
   s++;
  }
  return NULL;//未匹配到字符串 
}
void get_a_row(FILE*fp, char buf[]){
	//读入回车符地读取一行
    int i=0;
    while(!feof(fp)){
		if((buf[i++]=fgetc(fp))=='\n')
		  break;
	}
    buf[i]='\0';
   //测试用printf("%s",buf);
}
FILE*to_row(FILE*fp, char *t){
	//转到字符串 t 所在行的下一行 
	char buf[MAXLINELENGTH];
	FILE*tmp=fp;
	int flag=0;
	while(!feof(fp)){
		get_a_row(fp,buf);
		if(strsearch(buf,t)!=NULL&&strsearch(t,buf)!=NULL) //两个字符串完全相等 
		   {
		   flag=1;
		   break;
		   }
	} 
	if(flag)
	  return fp;
	else{
		printf("\ncannot go to the line after \"%s\"\n",t);
		return tmp;
	}
		
}
void deletepara(FILE*fp,FILE*fp2,char*startflag,char*endflag){
	//(demo)删除指定段:从startflag开始，到（包括）endflag为止，endflag必须为完整的结束行 
	char buf[MAXLINELENGTH];
	//char startflag[MAXLINELENGTH],endflag[MAXLINELENGTH];
	/*printf("Enter STARTFLAG:\n");
	scanf("%s",startflag);
	printf("Enter ENDROW:(must be an entire row)\n");
	scanf("%s",endflag);
	*/
	while(!feof(fp)){
		get_a_row(fp,buf);
		if(strsearch(buf,startflag)!=NULL)
		   fp=to_row(fp,endflag);
		else
		   fputs(buf,fp2);				
	}
	if(feof(fp))
	  printf("Deletion finished!\n");
}
void scan_a_person(FILE*fp,struct contact *p){
	char buf[MAXLINELENGTH];
	int count;
	//long position=ftell(fp); //保存文件指针位置 
	get_a_row(fp,buf);//读取一行 
	if(strsearch(buf,"BEGIN:")==buf)//识别名片开头 
	{
	   count=0;
	   get_a_row(fp,buf);
	   while(strsearch(buf,"END:")!=buf){
	   	
	   	if(strsearch(buf,"FN:")==buf){
	   		sscanf(buf,"FN:%s",p->name);
		   }
		if(strsearch(buf,"TEL;TYPE=")==buf)
	   		switch(count){
	   			case 0:
				   sscanf(buf,"%*[^:]:%[0-9| ]s",p->tel);//正则表达式，表示读到冒号后读入冒号后的空格或数字 
	   			   count++;
	   			   break;
	   			case 1:
	   				sscanf(buf,"%*[^:]:%[0-9| ]s",p->tel1);
	   				count++;
	   				break;
	   			case 2:
	   				sscanf(buf,"%*[^:]:%[0-9| ]s",p->tel2);
	   				count++;
	   				break;
	   			case 3:
	   				sscanf(buf,"%*[^:]:%[0-9| ]s",p->tel3);
	   				count++;
	   				break;
	   			default:
	   			   if(count>=4)
				     {
				     	printf("%s has too many telephone numbers!\n",p->name);
				     	return;
					 }
				   //exit(6);
			   }
			  
		   
		    get_a_row(fp,buf);
	   }
	} 
	   
	/*if(fseek(fp,position,SEEK_SET)){
    	printf("cannot return to previous position!\n");
    	exit(5);
	}
	*/
}
struct contact* daoru(FILE*fp){
	//导入vcf文件中的所有联系人,返回首地址 
	int id=0;
	char choice;
	struct contact *p,*tmp,*head=NULL;
				
	while(!feof(fp)){
				
			//动态分配内存 
			if((p=(struct contact*)malloc(sizeof(struct contact)))==NULL){
				printf("cannot allocate memory!");
				exit(6);
			}
			//初始化全为'\0'，有一定影响，未知原因 
			
			memset(p->tel, 0, 12*sizeof(char));
			memset(p->tel1, 0, 12*sizeof(char));
			memset(p->tel2, 0, 12*sizeof(char));
			memset(p->tel3, 0, 12*sizeof(char));
			
			id++;
			/*if(id==1)
				head=tmp;
				*/
			//***倒序***存放联系人 
			tmp=head;
			scan_a_person(fp,p);//读取单个联系人信息 
			p->id=id;
			p->next=tmp;
			head=p;
		}

	  
	  return head;
}
main(){
	FILE*fp,*fp2;
	long position=0;
	int choice=-1,printflag=0;
	char buf[MAXLINELENGTH];
	static char filename[50];
	//定义循环链表，用于保存联系人信息 
	struct contact *p,*tmp,*head=NULL;
	//获取文件名
	 printf("filename:\n");
	 scanf("%s",filename);
	//打开文件
	if((fp=fopen(filename,"r"))==NULL){
		printf("cannot open \"%s\"!",filename);
		exit(1);
	}
	if((fp2=fopen("read_output.txt","w"))==NULL){
		printf("cannot create \"read_output.txt\"!");
		exit(2);
	}
	//核心部分
	
	/*
	//删除PHOTO段测试 
	char s[]="PHOTO;",t[]="\n";
	deletepara(fp,fp2,s,t);
	*/
	/*
	//识别单个联系人测试
	position=ftell(fp); 
	
	get_a_row(fp,buf);
	if(strsearch(buf,"BEGIN:")==buf)
	   while(1){
	   	printf("%s",buf);
	   	get_a_row(fp,buf);
	   	if(strsearch(buf,"END:")==buf){
	   		printf("%s",buf);
	   		break;
		   }
	   }
	
    if(fseek(fp,position,SEEK_SET)){
    	printf("cannot return to previous paragraph!\n");
    	exit(5);
	}
	*/
	
	//导入所有联系人测试 
	//head=daoru(fp,fp2); 
	head=daoru(fp);
	while(!printflag){
		printf("Enter choice:[1.print on the screen | 2 write to file]\n");
		scanf("%d",&choice);  //此处有bug，输入英文会进入死循环 
		switch(choice){
			case 1://显示在屏幕上 
				printf("%-6s%-32s%27s%27s%27s%27s\n","编号","姓名","电话1","电话2","电话3","电话4"); 
				p=head;
				while(p!=NULL){
				   	printf("%-6d%-32s%27s%27s%27s%27s\n",p->id,p->name,p->tel,p->tel1,p->tel2,p->tel3);
				   	tmp=p->next;
				    free(p);
				    p=tmp;
				 }
				printflag=1;
				break;
			
			case 2://输出到文件
				p=head;
				while(p!=NULL){
				   	fprintf(fp2,"%04d;%s;%s;%s;%s;%s\n",p->id,p->name,p->tel,p->tel1,p->tel2,p->tel3);
				   	tmp=p->next;
				    free(p);
				    p=tmp;
			  } 
			  printf("\nWrite to file completed!\n");
			  printflag=1;
				break;
			default:
			    printf("Invalid number!\n");
			    printflag=0;
		
		}
	
	} 
	
    
    
    //system("pause"); 
	//关闭文件
	if(fclose(fp)){
		printf("cannot close \"%s\"!",filename);
		exit(3);
	}
	if(fclose(fp2)){
		printf("cannot close \"read_output.txt\"!");
		exit(4);
	}
	return 0;
}

